#include<stdio.h>

//环形链表  在链表当中属于中上难度的题 也是大厂特别爱考的题
//因为这个题很容易错

//给定一个链表，判断链表中是否有环

//如果链表中有某个节点 可以通过连续跟踪next指针再次到达 则链表中存在环 
//为了表示给定链表中的环 我们使用整数pos来表示链表尾连接到链表中的位置
//索引从0开始 如果pos是-1 则在该链表中设有环 注意：pos不作为参数就行传递
//仅仅是为了标识链表的实际情况

//如果链表中存在环 则返回1 否则 返回-1

//循环链表就是带环链表当中的一种（到了尾之后，又指向了头）约瑟夫环
//解决约瑟夫环 最好用链表 直到最后就剩一个人了 就是约瑟夫环的解
//有些时候 需要这个数据在环里面 就把最后一个节点的next 指向第一个
//这样就形成了一个环 或者连接到中间的某个数据 这样的意思就是
//多个节点的next指向一个节点 就形成了带环 最粗暴的带环就是
//是自己指向自己 带环问题最恶心的是不能遍历 不会报NULL

//题目是判断链表是否带环
//这道题还是用快慢指针来做 快指针会先进环 慢指针会后进环
//最终两个指针都会在环里面打转 速度不一样 快指针会追上慢指针
//当相遇的时候 两个的地址就一样了 就可以停止了

hasCycle(struct  ListNode* head)
{
    struct ListNode* slow =head;
    struct ListNode* fast =head:
    while (fast && fast->next)//以fast和fast->next来判断结束
    //因为fast一次走两步 fast=fast->next 要保证fast不为NULL
    //fast->next->next不为NULL 所以就要保证fast->next不为NULL
    //这样才能走两步 因为不能确定这个链表一定是带环的
    {
        slow=slow->next;
        fast=fast->next->next;
        //如果带环的话 这里就无穷无尽 一直在打圈
        if(slow ==fast)
        {
            return 1;
        }
    }
    return -1;//因为跳出循环 说明指向NULL了 就说明不是环
}
int main()
{
    return 0;
}