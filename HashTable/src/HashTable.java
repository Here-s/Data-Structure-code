import java.util.HashMap;
import java.util.Map;

public class HashTable {

    //在一组数据当中，找到想要的关键字，最差得 O(N) 时间复杂度，二叉搜索树当中找的话：最好是：log 以2为底 N。最差是 n
    //不经过任何比较，就能找到数据：时间复杂度：O(1)  这种数据结构就是哈希表：存的时候，就按照某个方法存，拿的时候也是按照某个方法拿
    //哈希表，也被叫做散列表

    //存放到哈希表当中，要通过一个哈希函数来完成：哈希函数可以由我们自己来设计
    //不同的的关键字，通过相同的哈希函数，有可能找到相同的位置。此时的情况：哈希冲突/哈希碰撞。
    //如果是负数的话，把它加上某个值，然后变为正数

    //哈希表底层的数组长度，往往是小于关键字个数的。所以就应该尽力降低冲突。所以每个位置都可以存好几个数据，所以每个位置就是链表了。
    //冲突是不可避免的：发生冲突之前，尽力去避免冲突：
    // 1、哈希函数的设计：哈希函数的定义域，必须包含需要存储的全部码，比如说值最大到10，
    //      那么哈希函数必须是 0-9 之间。只要能满足线性函数的散列地址就好了
    // 2、调节负载因子：负载因子就是存入散列表元素的个数/散列表的长度。一般的哈希表的负载因子是 0.75 负载因子越大，冲突率越大
    //      负载因子想变小的话，就应该调整哈希表的长度了。
    //解决冲突：
    // 1、闭散列：开放地址法。
    //      线性探测：当前位置被占领之后，向后找，找到第一个为空的位置，然后把它放进去。把冲突元素全放在一起了，
    //              但是删除就麻烦，删掉之后当前位置的冲突元素就找不到了，得做一个标志位
    //      二次探测：(H+i^2)%m 通过公式得到这个位置。最大局限性，装载英子，不能超过 0.5 也就是会浪费一般的空间
    // 2、开散列：哈希桶(HashBuck)，链地址法。底层就是数组+链表的形式。因为有负载因子，所以链表的长度控制在常数范围，
    //              从 JDK1.8开始，链表长度超过 8，数组长度超过 64，这个链表长度就会变成红黑树

    public int firstUniqChar(String s) {
        Map<Character,Integer> map = new HashMap<>();
        for (char ch : s.toCharArray()) {
            map.put(ch, map.getOrDefault(ch,0)+1);
        }
        for (int i = 0; i < s.length(); i++) {
            if (map.get(s.charAt(i)) == 1) {
                return i;
            }
        }
        return -1;
    }
    public static void main(String[] args) {
        //默认容量是 16
        HashMap<String, Integer> hashMap1 = new HashMap<>();
        //容量是 20 但是最终数组的大小是大于 20 并且是最接近 20 的一个二次幂 也就是 32
        HashMap<String, Integer> hashMap2 = new HashMap<>(20);
        //也可以传容量 有可以传 负载因子
        HashMap<String, Integer> hashMap = new HashMap<>();

    }
}
