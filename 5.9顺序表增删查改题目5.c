#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>


//旋转数组
//给定一个数组 将数组中的元素向右移动 k 个位置，其中k是非负数

//进阶
//    1 尽可能想出更多的解决方案，至少有三种不同的放大可以解决这个问题
//    2 你可以使用空间复杂度为O(1)(不能开辟新的空间)的原地算法解决这个问题吗？

//举例：输入nums=[1,2,3,4,5,6,7] k=3
//      输出 [5,6,7,1,2,3,4] 

//解释 旋转一步 把7旋转到最前面  旋转第二步 把六旋转到最前面 旋转第三步 把5旋转到最前面

//每次旋转一步 时间复杂度是O(n)因为有 n-1 个数被挪动 还有一个移到前面
//要旋转k次 所以时间复杂度是 k*O(n) 也就是 O(k*n) 

//方法一：每次旋转一个 保存最后一个 前 n-1 个数依次往后挪动 最后一个数放到第一个的位置
//旋转k次 时间复杂度是 O(k*n) 如果旋转次数比数组元素大的话 就模数组元素-1就好了

//方法二：因为要旋转三次 所以就可以把后三个数放在一个新开的数组当中 数组大小是k 
//把后k个往前挪 把k个放前去  以空间换时间  时间复杂度就是 O(n) 空间复杂度就是 O(k)
//不满足要求

//方法三：[1,2,3,4,5,6,7] k=3 先把前n-k个逆置 就是把前四个逆置 [4,3,2,1] 再把后k个逆置 变成[7,6,5]
//就变成了[4,3,2,1,7,6,5] 然后再整体逆序一下 就是[5,6,7,1,2,3,4] 整体逆置  时间复杂度O(n) 空间复杂度是O(1) 

//因为要对前n-k个逆置 对后k个逆置 要逆置数组中的一部分 所以通过下标去标识这个区间
void reverse(int* nums, int left, int right)//逆置函数
{
	while (left < right)
	{
		int tmp = nums[left];
		nums[left] = nums[right];
		nums[right] = tmp;
		++left;
		--right;
	}
}
void rotate(int* nums, int numsSize, int k)
{	
	k %= numsSize;//k有可能大于nums 所以取模 这样就没问题了 如果旋转7次 就相当于只需要余数去旋转
	reverse(nums, 0, nums - k - 1);
	reverse(nums, numsSize-k, numsSize - 1);//通过这两布 完成两部分逆置
	reverse(nums, 0, nums - 1);//最后的整体逆置
}
int main()
{
	return 0;
}