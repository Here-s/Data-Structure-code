#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//环形链表2
//给定一个链表，返回链表开始入环的第一个节点，如果链表无环 则返回NULL

//为了表示给定链表中的环，我们使用整数pos来表示链表尾连接到链表中的位置(索引从0开始)
//如果pos是-1，则在该链表中没有环。注意 pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中
//说明：不可以修改给定的链表  使用O(1)空间解决此题 环的第一个点就是环的入口点

//第一种方法：写起来麻烦 理解起来简单 快慢指针 会有相遇点 把相遇点断开 把断开的地方作为一个头
//原来的头 和现在新的头 环的入口就是这两个链表的相交点 这样求链表的交点就好了
//不过思路很简单

//方法二：写起来简单 但是理解难 并且需要公式证明  划分出三个段 第一段l是从开始到环的入口点
//第二段x是从环的入口点到相遇点 第三段 假设环的周长是c   慢指针走了l+x 快指针走了l+x+c
//慢指针一定是走了不到一圈就被快指针追上了 因为快指针每次比慢指针多走一步 所以快指针
//快指针走的距离就是慢指针的二倍 所以2*(l+x)=l+x+c l+x=c l=c-x 所以一个指针从相遇点走
//一个指针从链表头开始走 会在环入口点相遇 如果不相等就继续 相等就结束 这样就找到相遇点了
//（但是这个结论的前提是快指针与慢指针相遇的时候 快指针多走了一圈）
// 
//但是会被面试官反推掉这个代码  如果相遇的时候快指针比慢指针走的多了不止一圈 也就是前面越长
//环越小 慢指针进环的时候 快指针走了不止一圈 上面的推论就不行了 但是结论是对的 因为是实际的一种特殊情况
//错在 慢指针走的距离是l+x 快指针走的是l+nc+x 环越小 n越大 2(l+x)=l+n*c+x 所以 l+x=n*c
//l=n*c-x 如果n=1 就是上面的情况 所以上面其实是下面的一种情况 未知数太多 求不出解 但是能得出刚才的结论
//因为l=n*c-x 也能推出一个指针从相遇点走 一个指针从链表开始走 他们相遇的点 就是环的入口点
//走n*c就是又走到相遇点 再-x就是走到环的入口点 n*c-x=l 所以也可以这样走
//重要的不是写代码 而是推代码的过程

typedef struct ListNode//这里一定要有tydedef
{
    struct ListNode* next;
    int val;
}ListNode;
struct ListNode* detectCycle(struct ListNode* head)
{
    ListNode* slow;
    ListNode* fast;
    slow = fast = head;
    while (fast && fast->next)//这里是用快慢指针找到相遇点
    {
        slow = slow->next;
        fast = fast->next->next;        
        if (fast == slow)//不能一上来就判断 因为刚开始就是相等的
        {
            break;
        }
    }
    if (fast ==NULL || fast->next == NULL)//不带环的话一个走到尾了 用来判断只有一个节点的情况
    {
        return NULL;
    }
    ListNode* meet = fast;
    while (head != meet)
    {
        head = head->next;
        meet = meet->next;
    }
    return meet;//相等的那个点 就是相遇的点 所以返回就行了
}
int main()
{
	return 0;
}